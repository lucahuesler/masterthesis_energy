# Automated machine learning

## Modelling per building class
### Prepare
```{r}
library(h2o)
library(tidymodels)
library(tidyverse)
source("auto_ml_functions.R")
h2o.init()

# read data
energy_modelling <- read_rds("data/energy_modelling.rds") |>
  select(egid, 
           hepi, 
           hec, 
           survey_year, 
           num_residents_mean, 
           heated_area_m2, 
           year_of_installation, 
           efficiency_of_installation, 
           energy_usage_of_installation, 
           municipality_name, 
           building_class, 
           construction_year, 
           meters_above_sealevel, 
           energy_production_solar_mwh, 
           energy_consumed_hot_water_mwh,
           retrofitted,
           hdd,
           foreign_ratio,
           household_1_person_ratio,
           elderly_ratio,
           youth_ratio,
           residence_less_1_year_ratio,
           hepi_pred_current_method,
           hec_pred_current_method,
           stand_alone)


# split per building class
data_by_building_class <- split(energy_modelling, energy_modelling$building_class)
```


### Explore
#### Building class
```{r}

# Perform analysis on building_class variable
building_class_analysis <- energy_modelling %>%
  group_by(building_class) %>%
  summarize(
    count = n(),
    average_hec = mean(hec),
    average_hepi = mean(hepi)
  )

# Plotting the analysis results
ggplot(building_class_analysis, aes(x = building_class, y = average_hec)) +
  geom_bar(stat = "identity", fill = "skyblue", width = 0.5) +
  labs(title = "Average HEC by Building Class",
       x = "Building Class",
       y = "Average HEC") +
  theme_bw()

ggplot(building_class_analysis, aes(x = building_class, y = average_hepi)) +
  geom_bar(stat = "identity", fill = "lightgreen", width = 0.5) +
  labs(title = "Average HEPI by Building Class",
       x = "Building Class",
       y = "Average HEPI") +
  theme_bw()

```

#### Year of installation
```{r}
# Perform analysis on cleaned data
year_installation_analysis <- cleaned_data %>%
  group_by(year_of_installation) %>%
  summarize(
    count = n(),
    average_hec = mean(hec),
    average_hepi = mean(hepi)
  )

# Get the minimum value of year_of_installation
min_year <- min(year_installation_analysis$year_of_installation)

# Plotting the analysis results
ggplot(year_installation_analysis, aes(x = year_of_installation, y = average_hec)) +
  geom_bar(stat = "identity", fill = "skyblue", width = 0.5) +
  labs(title = "Average HEC by Year of Installation",
       x = "Year of Installation",
       y = "Average HEC") +
  theme_bw() +
  coord_cartesian(xlim = c(min_year, max(year_installation_analysis$year_of_installation)))

ggplot(year_installation_analysis, aes(x = year_of_installation, y = average_hepi)) +
  geom_bar(stat = "identity", fill = "lightgreen", width = 0.5) +
  labs(title = "Average HEPI by Year of Installation",
       x = "Year of Installation",
       y = "Average HEPI") +
  theme_bw() +
  coord_cartesian(xlim = c(min_year, max(year_installation_analysis$year_of_installation)))



```

#### Construction period
```{r}
# Perform analysis on construction_period variable
construction_period_analysis <- energy_modelling %>%
  group_by(construction_period, building_class) %>%
  summarize(
    count = n(),
    average_hec = mean(hec),
    average_hepi = mean(hepi)
  )

# Translate construction period codes to shortened labels
construction_period_analysis <- construction_period_analysis %>%
  mutate(construction_period_label = case_when(
    construction_period == 8011 ~ "vor 1919",
    construction_period == 8012 ~ "1919-1945",
    construction_period == 8013 ~ "1946-1960",
    construction_period == 8014 ~ "1961-1970",
    construction_period == 8015 ~ "1971-1980",
    construction_period == 8016 ~ "1981-1985",
    construction_period == 8017 ~ "1986-1990",
    construction_period == 8018 ~ "1991-1995",
    construction_period == 8019 ~ "1996-2000",
    construction_period == 8020 ~ "2001-2005",
    construction_period == 8021 ~ "2006-2010",
    construction_period == 8022 ~ "2011-2015",
    construction_period == 8023 ~ "ab 2016",
    TRUE ~ "Unknown"
  ))
# Reorder the construction period factor levels based on code
construction_period_analysis$construction_period_label <- factor(construction_period_analysis$construction_period_label, levels = unique(construction_period_analysis$construction_period_label))

# Plotting the analysis results with ordered x-axis labels, vertical x-axis labels, and differentiated bars by building class
ggplot(construction_period_analysis, aes(x = construction_period_label, y = average_hec, fill = building_class)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.5) +
  labs(title = "Average HEC by Construction Period and Building Class",
       x = "Construction Period",
       y = "Average HEC",
       fill = "Building Class") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))


ggplot(construction_period_analysis, aes(x = construction_period, y = average_hepi)) +
  geom_bar(stat = "identity", fill = "lightgreen", width = 0.5) +
  labs(title = "Average HEPI by Construction Period",
       x = "Construction Period",
       y = "Average HEPI") +
  theme_bw()

```

### Fit & predict
```{r}
all_metrics_hec_subset_building_class <- data.frame()

# Run AutoML for each building class separately
models_by_building_class <- lapply(names(data_by_building_class), function(name) {

  # Get the name of the current element in the list
  df_name <- name

  # Retrieve the corresponding data frame
  df <- data_by_building_class[[name]]

  # Prepare data
  df <- df %>%
    select(egid, 
           hepi, 
           hec, 
           survey_year, 
           num_residents_mean, 
           heated_area_m2, 
           year_of_installation, 
           efficiency_of_installation, 
           energy_usage_of_installation, 
           municipality_name, 
           building_class, 
           construction_year, 
           meters_above_sealevel, 
           energy_production_solar_mwh, 
           energy_consumed_hot_water_mwh,
           retrofitted,
           hdd,
           foreign_ratio,
           household_1_person_ratio,
           elderly_ratio,
           youth_ratio,
           residence_less_1_year_ratio,
           hepi_pred_current_method,
           hec_pred_current_method,
           stand_alone)

  # Split data
  df_h2o <- as.h2o(df)
  split <- h2o.splitFrame(df_h2o, seed = 1)
  train <- split[[1]]
  test <- split[[2]]

  # Run AutoML
  # variable selection
  vars <- names(energy_modelling)

  # predictor variables for HEC overall
  predictors_hec_all <- vars[-which(vars %in% c("egid", "hec", "hepi", "hec_pred_current_method", "hepi_pred_current_method"))]

  # without social indicators
  predictors_without_social <- predictors_hec_all[-which(predictors_hec_all %in% c("foreign_ratio","household_1_person_ratio","elderly_ratio","youth_ratio","residence_less_1_year_ratio"))]

  aml_results <- run_h2o_automl(target = "hec", 
                                predictors = predictors_without_social, 
                                data = train, 
                                runtime = 7200)

  # Get the leaderboard for this subset
  leaderboard <- h2o.get_leaderboard(aml_results$aml, extra_columns = "algo") |>
    as.data.frame() |>
    mutate(approach = df_name)

  # Loop over the leaderboard and predict on the corresponding test set
  for (i in 1:nrow(leaderboard)) {
    # Extract the model_id, algorithm, and approach columns
    model_id <- as.character(leaderboard[i, "model_id"])
    algorithm <- as.character(leaderboard[i, "algo"])
    approach <- as.character(leaderboard[i, "approach"])
    print(paste0(model_id, " / ", algorithm, " / ", approach))

    # Get the model from the H2O AutoML object
    model <- h2o.getModel(model_id)

    # Make predictions on the test dataset
    predictions <- h2o.predict(model, test)

    # Call the calc_metrics function to get the metrics
    metrics <- calc_metrics(model, test, predictions, target = "HEC") |>
      bind_cols(Algorithm = algorithm) |>
      bind_cols(Approach = approach)

    # Add the metrics to the data frame
    all_metrics_hec_subset_building_class <- bind_rows(all_metrics_hec_subset_building_class, metrics)
  }

    ## Model evaluation
  # Retrieve the best model
  best_model <- h2o.get_best_model(aml_results$aml)

  # Predict with the best model
  best_model_predictions <- h2o.predict(best_model, test)
  
  # Combine data frames
  test_preds <- test |>
    h2o.cbind(best_model_predictions) |>
    as.data.frame()

  # Calculate aggregated errors
  aggregated_error_curr_method <- 1 - sum(test_preds$hec_pred_current_method)/sum(test_preds$hec)
  aggregated_error_best_model <- 1 - sum(test_preds$predict)/sum(test_preds$hec)

  # Return the AutoML results
  return(list(building_class = df_name, 
              aml_results = aml_results, 
              train_metrics = leaderboard, 
              test_metrics = all_metrics_hec_subset_building_class, 
              aggregated_error_curr_method = aggregated_error_curr_method,
              aggregated_error_best_model = aggregated_error_best_model,
              test_preds = test_preds,
              algo_best_model = best_model@algorithm))
})

# Combine metrics of each subset into one data frame
subset_building_class_train_metrics <- map_dfr(models_by_building_class, ~ .x$train_metrics)
subset_building_class_test_metrics <- map_dfr(models_by_building_class, ~ .x$test_metrics)

# Combine aggregated errors
building_class <- map_dfr(models_by_building_class, ~ data.frame(building_class = .x$building_class))
aggregated_error_curr_method <- map_dfr(models_by_building_class, ~ data.frame(aggregated_error_curr_method = .x$aggregated_error_curr_method))
aggregated_error_best_model <- map_dfr(models_by_building_class, ~ data.frame(aggregated_error_best_model = .x$aggregated_error_best_model))

aggregated_errors_building_class <- building_class |>
  bind_cols(aggregated_error_best_model) |>
  bind_cols(aggregated_error_curr_method)


```


