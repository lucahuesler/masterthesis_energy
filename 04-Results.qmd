# Results {#sec-results}

In this chapter, the results of our analysis will be presented. In a first step, we will conduct a descriptive and exploratory analysis in @sec-exploratory-analysis of the data used for modelling. In @sec-model-evaluation, we will present and compare the results of the different models. Finally in @sec-final-model, we will provide the results of the final model and the sensitivity analysis of the input features.

```{r}
#| label: load-libs
#| include: false

library(tidyverse)
library(tidymodels)
library(skimr)
library(plotly)
library(sf)
library(agua)
library(gt)
```

```{r}
#| label: load-data
#| include: false

energy_modelling <- read_rds("data/energy_modelling.rds")
```

## Exploratory Analysis {#sec-exploratory-analysis}

To gain a first overview of the data that we use for modelling, we here present the summary statistics and visual exploration of the data.

### Summary statistics

As outlined in @sec-data-preprocessing, we applied several filters to the initial raw data. Thus, the final dataset for modelling contains `r nrow(energy_modelling)` observations (buildings). As we consider data from the years 2016, 2018 and 2020, one building can be present in the dataset three times at maximum. @tbl-obs-per-year shows that the number of gas-heated buildings is slightly decreasing between 2016 and 2020. Also, we observe a decrease of the mean HEPI and the total HEC between 2016 and 2020.

```{r}
#| label: tbl-obs-per-year
#| tbl-cap: "Number of buildings per survey year."
#| tbl-cap-location: bottom

obs_per_year <- energy_modelling |>
  dplyr::group_by(survey_year) |>
  dplyr::rename("Survey Year" = survey_year) |>
  dplyr::summarise(Count = n(),
                   "Mean HEPI (kWh/m2/year)" = mean(hepi),
                   "Sum HEC (GWh/year)" = sum(hec)/1000) |>
  knitr::kable(booktabs = TRUE, digits = 1)

obs_per_year
```



```{r}
#| label: tbl-obs-per-year-municipality
#| tbl-cap: "Mean HEPI and sum HEC per survey year and municipality."
#| tbl-cap-location: bottom

obs_per_year_municipality <- energy_modelling |>
  dplyr::group_by(survey_year, entrance_municipality_name) |>
  dplyr::rename("Survey Year" = survey_year,
                "Municipality" = entrance_municipality_name) |>
  dplyr::summarise(Count = n(),
                   "Mean HEPI (kWh/m2/year)" = mean(hepi),
                   "Sum HEC (GWh/year)" = sum(hec)/1000) |>
  dplyr::arrange(desc("Mean HEPI (kWh/m2/year)")) |>
  knitr::kable(booktabs = TRUE, digits = 1)

obs_per_year_municipality
```


```{r}
#| label: tbl-summary-stats
#| tbl-cap: "Summary statistics of modelling input data."
#| tbl-cap-location: bottom

summary_stats_numeric <- energy_modelling %>%
  skim() %>%
  yank("numeric")

summary_stats_numeric
```

### Retrofitting

```{r}
#| label: tbl-retrofit
#| tbl-cap: "Mean HEPI of retrofitted versus non-retrofitted."
#| tbl-cap-location: bottom

retrofit_mean_hepi <- energy_modelling %>%
  dplyr::group_by(survey_year, building_class, retrofitted) %>%
  dplyr::summarise("Mean HEPI" = mean(hepi))

retrofit_mean_hepi
```

```{r}
#| label: fig-retrofitting-investment-costs
#| fig-cap: "Correlation between retrofit investment costs and HEPI"

retrofit_investment_plot <- energy_modelling %>%
  filter(!is.na(retrofit_investment_costs)) %>%
  ggplot((aes(retrofit_investment_costs, hepi))) +
           geom_point() +
  facet_grid(vars(building_class))

retrofit_investment_plot
```


```{r}
#| label: fig-retrofitting
#| fig-cap: "Construction year per municipality"

retrofit_plot <- energy_modelling %>%
  filter(retrofitted == TRUE) %>%
  arrange(desc(egid)) %>%
  distinct(egid, survey_year, energy_consumed_measured_mwh) %>%
  pivot_wider(names_from = survey_year, names_prefix = "energy_consumed_measured_mwh_", values_from = energy_consumed_measured_mwh) 

retrofit_plot %>%
  ggplot((aes(energy_consumed_measured_mwh_2018, energy_consumed_measured_mwh_2016))) +
           geom_point() +
  xlim(0,200) +
  ylim(0,200) +
  geom_abline(intercept = 0, slope = 1)
```


### Density and boxplots

```{r}
#| label: tbl-summary-municipality
#| tbl-cap: "Summary statistics per municipality"
#| tbl-cap-location: bottom

#> Filter to relevant buildings for modelling

summary_table <- energy_modelling %>%
  group_by(entrance_municipality_name, building_class) %>%
  summarise(n = n()) %>%
  pivot_wider(names_from = building_class, 
              values_from = n)

summary_table
```

```{r}
#| label: boxplot-municipality
#| include: false

#> basic function
plot_boxplot <- function(df, y_axis) {
  y_axis <- sym(y_axis)
  df %>%
    mutate(class = fct_reorder(entrance_municipality_name, !!y_axis, .fun='median')) %>%
    ggplot( aes(x=reorder(entrance_municipality_name, !!y_axis), y=!!y_axis, fill=entrance_municipality_name)) + 
      geom_boxplot() +
      xlab("class") +
      theme(legend.position="none") +
      xlab("") +
      labs(paste0(y_axis," per municipality")) +
      coord_flip()
}
#> Creating boxplots for different input variables
boxplot_construction_year <- plot_boxplot(energy_modelling, "construction_year")
boxplot_building_area_m2 <- plot_boxplot(energy_modelling, "building_area_m2")
boxplot_num_residents <- plot_boxplot(energy_modelling, "num_residents")
boxplot_hepi <- plot_boxplot(energy_modelling, "hepi")

boxplot_year_of_installation <- energy_modelling %>%
  filter(year_of_installation > 1900) %>%
  plot_boxplot(., "year_of_installation")

```

```{r}
#| label: fig-municipality-hepi
#| fig-cap: "HEPI per municipality"
#| include: false

ggplotly(boxplot_hepi)

```

```{r}
#| label: fig-municipality-construction-year
#| fig-cap: "Construction year per municipality"

ggplotly(boxplot_construction_year) 

```


### Ridgeline plots

```{r}
# library
library(ggridges)
library(ggplot2)
library(viridis)
library(hrbrthemes)

# Plot
energy_modelling %>%
  filter(building_class == 1110) %>%
  ggplot(aes(x = hepi, y = entrance_municipality_name, fill = after_stat(x))) +
  geom_density_ridges_gradient(scale = 5, rel_min_height = 0.02) +
  scale_fill_viridis(name = "HEPI (kWh/m2)", option = "C") +
  labs(title = 'HEPI per municipality') +
  xlim(0,300)
```



## Modelling

### Train/test split

```{r}
#| label: train-test-split
#| include: false

#> select variables for modelling
df_energy_modelling <- energy_modelling %>%
  select(egid, hepi, survey_year, num_residents, gross_floor_area_m2, year_of_installation, efficiency_of_installation, energy_usage_of_installation, solar_system, solar_system_area_m2, solar_system_usage, solar_system_area_m2, photovoltaic_system, photovoltaic_system_power_kw, district_heating_role, heated_by_egid, municipality_code, building_category, building_class, construction_year, building_area_m2, energy_reference_area, coordinate_e, coordinate_n, num_floors, num_separate_living_space, num_dwellings, meters_above_sealevel, energy_production_solar_mwh, energy_consumed_hot_water_mwh, admin_project_type)


df_energy_modelling_test <- df_energy_modelling %>%
  select(egid, hepi, survey_year, num_residents, gross_floor_area_m2, year_of_installation, num_dwellings, energy_consumed_hot_water_mwh, energy_production_solar_mwh)
         
#> Set the random number stream using `set.seed()` so that the results can be 
#> reproduced later. 
set.seed(501)

#> Save the split information for an 80/20 split of the data
energy_split <- initial_split(df_energy_modelling, prop = 0.80, strata = hepi)
energy_split


#> Creating train and test set
energy_train <- training(energy_split)
energy_test  <-  testing(energy_split)

dim(energy_train)
```

### Preprocessing

In the preprocessing, we apply the following:

-   Remove multicollinearity: Predictor variables that have a correlation above +/- 0.8 will me removed
-   Normalize numeric variables
-   Log-transform numeric variables
-   Create dummy variables from all nominal variables

```{r}
#| label: preprocessing-recipes
#| include: false


# Specify a recipe object
energy_base_recipe <- recipe(hepi ~ egid + survey_year + building_class + construction_year,
                          data = energy_train) %>% 
  # remove date from the list of predictors
  update_role(egid, new_role = "id") %>% 
  # Log-transform
  #step_log(all_numeric(), base = 10) %>%
  # Normalize numeric predictors
  #step_normalize(all_numeric_predictors()) %>% 
  # Create dummy variables for nominal predictors
  step_dummy(all_nominal())
```

### Defining models

```{r}
#| label: model-definition
#| include: false

lm_spec <- 
   linear_reg() %>% 
   set_engine("lm")

dt_spec <- 
   decision_tree(cost_complexity = tune(), min_n = tune()) %>% 
   set_engine("rpart") %>% 
   set_mode("regression")

knn_spec <- 
   nearest_neighbor(neighbors = tune(), weight_func = tune()) %>% 
   set_engine("kknn") %>% 
   set_mode("regression")

auto_ml_spec <- auto_ml() %>%
  set_engine("h2o") %>%
  set_mode("regression") 
  
```

### Define workflows

```{r}
#| label: workflow-definition
#| include: false

energy_models <- 
   workflow_set(
      preproc = list(simple = energy_base_recipe),
      models = list(lm = lm_spec, dt = dt_spec),
      cross = TRUE
   )

energy_models
```

### Training

```{r}
#| label: hyperparameter-tuning
#| include: false

splits <- vfold_cv(energy_train, v = 2, strata = hepi)

set.seed(123)
energy_models <- 
   energy_models %>% 
   # The first argument is a function name from the {{tune}} package
   # such as `tune_grid()`, `fit_resamples()`, etc.
   workflow_map("tune_grid", resamples = splits, grid = 10, 
                metrics = metric_set(rmse), verbose = TRUE)
```

### Model evaluation {#sec-model-evaluation}

```{r}
autoplot(energy_models)
```

```{r}
autoplot(energy_models, select_best = TRUE)
```

### Final model {#sec-final-model}

```{r}
best_results <- 
   energy_models %>% 
   extract_workflow_set_result("simple_lm") %>% 
   select_best(metric = "rmse")
best_results

dt_test_results <- 
   energy_models %>% 
   extract_workflow("simple_lm") %>% 
   finalize_workflow(best_results) %>% 
   last_fit(split = energy_split)

collect_metrics(dt_test_results)
```


```{r}
dt_test_results %>% 
   collect_predictions() %>% 
   ggplot(aes(x = hepi, y = .pred)) + 
   geom_abline(color = "gray50", lty = 2) + 
   geom_point(alpha = 0.5) + 
   coord_obs_pred() + 
   labs(x = "observed", y = "predicted")
```

### Multiple linear regression

```{r}
#| label: lm-fit
#| include: false
#| eval: false


#> create model
lm_model <- 
  linear_reg() %>% 
  set_engine("lm")

#> fit model on training data
lm_form_fit <- 
  lm_model %>% 
  fit(hepi ~ num_residents, data = energy_training_prep)

lm_form_fit
```

```{r}
#| label: lm-pred
#| include: false
#| eval: false


prediction <- lm_form_fit %>%
  predict(energy_test_prep)


test_res <- energy_test_prep %>%
  select(hepi) %>%
  bind_cols(prediction)

test_res <- test_res %>%
  mutate(hepi = exp(hepi),
         .pred = exp(.pred))
```

```{r}
#| label: lm-plot
#| include: false
#| eval: false

ggplot(test_res, aes(x = hepi, y = .pred)) + 
  #> Create a diagonal line:
  geom_abline(lty = 2) + 
  geom_point(alpha = 0.5) + 
  labs(y = "Predicted HEC", x = "Measured HEC") +
  #> Scale and size the x- and y-axis uniformly:
  coord_obs_pred()
```

### ANN

### Auto ML
